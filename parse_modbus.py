from __future__ import division # for python 2.7 to make number became float after divided, normally it's int
import serial
import signal


## NOTE this is for Python3, if you use for python 2.7 then will encounter payload type str which can failed in
## get_val_modbus function. Python3 serial COM will give output bytes type rather than str

A = "IFY"
a = "STRFINGIFYGILAIFY12345"
hint = b'\x01\x04\x08\x58\x00\x1e\xf3\xb1'
payload = [0x01,0x04,0x08,0x37,0x00,0x01,0x82,0x64,0x01,0x04,0x02,0x0,0xfb,0xf8,0xb3,0x1,0x1,0x0,0x27,0x0,0x5,0x4c,0x2,0x1,0x1,0x1,0x0,0x51,0x88,0x1,0x4,0x0,0x3,0x0,0x2,0x81,0xcb,0x1,0x4,0x4,0x0,0x0,0x5e,0xcf,0x83,0xb0,0x1,0x2,0x1,0x9c,0x0,0x14,0xb9,0xd7,0x1,0x2,0x3,0x8,0x2,0x7,0xb9,0x2e,0x1,0x1,0x0,0x0,0x0,0x9,0xfc,0xc,0x1,0x1,0x2,0x0,0x0,0xb9,0xfc,0x1,0x3,0x2,0x8c,0x0,0x7,0xc4,0x5b,0x1,0x3,0xe,0x11,0x94,0x1,0x2c,0x0,0x3,0x0,0x3,0x0,0x1e,0x0,0x0,0x0,0x0,0xd7,0x70,0x1,0x3,0x2,0x1a,0x0,0x1b,0x25,0xbe,0x1,0x3,0x36,0x3,0xe8,0x1,0xc2,0x0,0x3,0x0,0x3,0x0,0x3c,0x0,0x0,0xb,0xb8,0x1,0xc2,0x0,0x3,0x0,0x3,0x0,0x1e,0x0,0x0,0x3,0xe8,0x1,0xc2,0x0,0x0,0x0,0x0,0x0,0x1e,0x0,0x0,0x13,0x88,0x1,0xc2,0x0,0x3,0x0,0x0,0x0,0x1e,0x0,0x0,0x13,0x88,0x1,0xc2,0x0,0x0,0x73,0x73,0x1,0x3,0x0,0xbb,0x0,0xb,0x74,0x28,0x1,0x3,0x16,0x0,0x82,0x0,0x5,0x0,0x3,0x0,0x3,0x0,0x1e,0x0,0x0,0x0,0x64,0x0,0x5a,0x0,0x3,0x0,0x3,0x0,0x1e,0x1f,0xa5,0x1,0x3,0x1,0xf6,0x0,0x13,0xe5,0xc9,0x1,0x3,0x26,0xc3,0x50,0x1,0xc2,0x0,0x3,0x0,0x3,0x0,0x1e,0x0,0x0,0x3,0xe8,0x1,0xc2,0x0,0x3,0x0,0x3,0x0,0x3c,0x0,0x0,0xc3,0x50,0x1,0xc2,0x0,0x3,0x0,0x0,0x0,0x1e,0x0,0x0,0x3,0xe8,0x43,0xd,0x1,0x3,0x2,0xcc,0x0,0x7,0xc5,0x8f,0x1,0x3,0xe,0x0,0x64,0x3,0xe8,0x0,0xa0,0x0,0x3,0x0,0x0,0x0,0x1e,0x0,0x0,0xb2,0x97,0x1,0x4,0x8,0x1c,0x0,0x1c,0x32,0x65,0x1,0x4,0x38,0x0,0x0,0x97,0x2b,0x4,0x99,0x34,0xd7,0x0,0xb3,0xdc,0xe4,0x7,0xd3,0x46,0x58,0xc6,0x7d,0x9b,0x69,0x0,0x44,0x4,0xa0,0x1,0x2,0x1,0x3,0x1,0x3,0x1,0x3,0x1,0x3,0x1,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x13,0x0,0x1f,0x0,0x68,0x0,0xfd,0x2d,0x5b,0x1,0x3,0x2,0xef,0x0,0xf,0x35,0x83,0x1,0x3,0x1e,0x0,0xc8,0x0,0x50,0x0,0x3,0x0,0x3,0x0,0x1e,0x0,0x0,0x0,0x0,0x0,0x0,0x7d,0x0,0x0,0x64,0x0,0xa,0x0,0x0,0x0,0x64,0x0,0xa,0x0,0x0,0x37,0x83,0x1,0x3,0x1,0x6,0x0,0x2,0x25,0xf6,0x1,0x3,0x4,0x0,0x55,0x0,0x0,0xea,0x23,0x1,0x3,0x3,0x98,0x0,0x9,0x4,0x67,0x1,0x3,0x12,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa,0x72,0x85,0x1,0x4,0x8,0x58,0x0,0x1e,0xf3,0xb1,0x1,0x4,0x3c,0x29,0x1b,0x6c,0xf1,0x0,0x0,0xb,0x21,0xb,0xce,0x1,0x90,0x1,0xc5,0x0,0x3,0x49,0x2f,0x56,0x9b,0x0,0x0,0x1,0xc8,0xb,0x23,0x0,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x6,0xc8,0x0,0x0,0x21,0x0,0x9]

def get_val_modbus(index_array, payload):
	val_array=[]
	# print('get_val_modbus:', payload)
	# print('get_val_modbus type:',type(payload))
	for i in index_array:
		val_array.append(payload[i+11]<<8|payload[i+12])	#PI
		val_array.append(payload[i+13]<<8|payload[i+14])	#PD
		val_array.append(payload[i+17]<<8|payload[i+18])	#TI
		val_array.append(payload[i+19]<<8|payload[i+20])	#TM
		val_array.append(payload[i])						#siteID
	return val_array

def get_sensor_min(payload,hint):
	counter=0
	index = 0
	looping=0
	result = []
	# print('get_sensor_min:', payload)
	# print('get_sensor_min type:',type(payload))
	while looping != -1:
		index=payload.find(hint,index)
		if(index!=-1):
			result.insert(counter,index)
		looping = index
		index += len(hint)
		counter += 1
	return result

def main():
	# signal.signal(signal.SIGINT, handler)
	res = []
	while(1):
		with serial.Serial('COM5', 9600, timeout=1) as ser:
			payload = ser.read(16*32)
			if(len(payload)>1):
				res=get_val_modbus(get_sensor_min(payload,hint),payload)
				if len(res)!=0:
					print("Site ID: %d\nPI: %.1f psi\nPD: %.1f psi\nTI: %.1f F\nTM: %.1f F\n\n"
						%(res[4],float(res[0]/10),float(res[1]/10),float(res[2]/10),float(res[3]/10)))


if __name__ == "__main__":
    main()